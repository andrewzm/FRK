% Generated by roxygen2 (4.0.2): do not edit by hand
\docType{methods}
\name{validate}
\alias{validate}
\alias{validate,list,Graph_2nodes-method}
\alias{validate,list-Graph_2nodes-method}
\alias{validate,matrix,Graph_2nodes-method}
\alias{validate,matrix-Graph_2nodes-method}
\title{Predictive statistics for small validation data}
\usage{
validate(Results, G, sim_obs = F, ...)

\S4method{validate}{list,Graph_2nodes}(Results, G, sim_obs = F)

\S4method{validate}{matrix,Graph_2nodes}(Results, G, sim_obs = F)
}
\arguments{
\item{Results}{a list generated by the function \code{Infer}}

\item{G}{an object of class \code{Graph_2nodes} describing the relationship between the observations and the processes.}

\item{sim_obs}{if set to \code{T}, the observations are ignored and `ideal' simulated observations are used instead. This option can be used to effect a `Turing test', where the real-data case and the ideal case can be compared side-by-side.}
}
\value{
A data frame with the predictive statistics as described above.
}
\description{
This function takes inferential results from \code{Infer} and computes predictive statistics on a validation data set. These include \code{RMS}, \code{PMCC}, \code{CR1} and \code{CR2} as defined in Sahu and Mardia (2005), and the Mahalanobis distance \code{Mahalanobis}, the eigenvalue errors \code{DE} and the pivoted Cholesky errors \code{DPC} as described in Bastos and O'Hagan (2009).
}
\examples{
require(Matrix)
data(icesat)
data(surf_fe)

## First create observation object
icesat_obs <- Obs(df=icesat,
                 abs_lim = 5,
                 avr_method = "median",
                 box_size=100,
                 name="icesat")

## Now split into a training/validation set
split_data <- split_validation(icesat_obs,sample=500,common=0, t==2)
icesat_validation <- split_data$O_val
icesat_training <- split_data$O_pruned

## Now create GMRF defined over some FE basis
Mesh <- initFEbasis(p=surf_fe$p,
                    t=surf_fe$t,
                    M=surf_fe$M,
                    K=surf_fe$K)

mu <- matrix(0,nrow(Mesh),1)
Q <- sparseMatrix(i=1:nrow(surf_fe$p), j = 1:nrow(surf_fe$p), x = 1)

my_GMRF <- GMRF(mu = mu, Q = Q,name="SURF",t_axis = 0:6)
SURF <-GMRF_basis(G = my_GMRF, Basis = Mesh)

L1 <- link(SURF,icesat_training)
e <- link_list(list(L1))
v <- block_list(list(O = icesat_training, G = SURF))
G <- new("Graph",e=e,v=v)
G_reduced <- compress(G)
Results <- Infer(G_reduced)

## Now we validate the results with icesat
L1 <- link(SURF,icesat_validation)
e <- link_list(list(L1))
v <- block_list(list(G1=SURF,O1=icesat_validation))
G <- Graph(e=e,v=v)
G_reduced <- compress(G)
val_results <- validate(Results,G_reduced,sim_obs=F)
}
\references{
Sahu, S. K., & Mardia, K. V. (2005). A Bayesian kriged Kalman model for short-term forecasting of air pollution levels. Journal of the Royal Statistical Society: Series C (Applied Statistics), 54(1), 223-244. Bastos, L. S. and O'Hagan, A. (2008). Diagnostics for Gaussian process emulators. Technometrics 51, 425-438.
}
\keyword{predictive}
\keyword{validation}
\keyword{variance,}

