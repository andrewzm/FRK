% Generated by roxygen2 (5.0.1): do not edit by hand
\docType{methods}
\name{eval_basis}
\alias{eval_basis}
\alias{eval_basis,Basis,STIDF-method}
\alias{eval_basis,Basis,SpatialPointsDataFrame-method}
\alias{eval_basis,Basis,SpatialPolygonsDataFrame-method}
\alias{eval_basis,Basis,matrix-method}
\alias{eval_basis,Basis-STIDF-method}
\alias{eval_basis,Basis-SpatialPointsDataFrame-method}
\alias{eval_basis,Basis-SpatialPolygonsDataFrame-method}
\alias{eval_basis,Basis-matrix-method}
\alias{eval_basis,TensorP_Basis,STIDF-method}
\alias{eval_basis,TensorP_Basis,matrix-method}
\alias{eval_basis,TensorP_Basis-STIDF-method}
\alias{eval_basis,TensorP_Basis-matrix-method}
\title{Evaluate basis functions}
\usage{
eval_basis(basis, s, output = "matrix")

\S4method{eval_basis}{Basis,matrix}(basis, s, output = "matrix")

\S4method{eval_basis}{Basis,SpatialPointsDataFrame}(basis, s,
  output = "matrix")

\S4method{eval_basis}{Basis,SpatialPolygonsDataFrame}(basis, s,
  output = "matrix")

\S4method{eval_basis}{Basis,STIDF}(basis, s, output = "matrix")

\S4method{eval_basis}{TensorP_Basis,matrix}(basis, s, output = "matrix")

\S4method{eval_basis}{TensorP_Basis,STIDF}(basis, s, output = "matrix")

\S4method{eval_basis}{Basis,STIDF}(basis, s, output = "matrix")
}
\arguments{
\item{basis}{object of class \code{Basis}}

\item{s}{object of class \code{matrix}, \code{SpatialPointsDataFrame} or \code{SpatialPolygonsDataFrame}}

\item{output}{either a "list" or "matrix", depending on desired output format.}
}
\description{
Evaluate basis functions at points or average functions over polygons
}
\details{
This function evaluates the basis functions at isolated points, or averages the basis functions over polygons, for computing the matrix \eqn{S}. The latter operation is carried out using Monte Carlo integration with 1000 samples per polygon. This function is embarassingly parallelisable and is thus Hadoop-enabled (provided a Hadoop backend is available and \code{opts_FRK$get("Rhipe")} is TRUE).
}
\examples{
library(sp)

### Create a synthetic dataset
d <- data.frame(lon = runif(n=1000,min = -179, max = 179),
                lat = runif(n=1000,min = -90, max = 90),
                z = rnorm(5000))
coordinates(d) <- ~lon + lat
proj4string(d)=CRS("+proj=longlat")

### Now create basis functions over sphere
G <- auto_basis(m = sphere(),data=d,
                nres = 2,prune=15,
                type = "bisquare",
                subsamp = 20000)

### Now evaluate basis functions at origin
S <- eval_basis(G,matrix(c(0,0),1,2))
}

